Q1. Query all columns for all American cities in the CITY table with populations larger than 100000.
The CountryCode for America is USA.
The CITY table is described as follows:

select *  from city
where COUNTRYCODE="USA" and POPULATION>100000;

==========================================================================================================================================================
Q2. Query the NAME field for all American cities in the CITY table with populations larger than 120000.
The CountryCode for America is USA.
The CITY table is described as follows:


select *  from city
where COUNTRYCODE="USA" and POPULATION>120000;
===================================================================================================================================================
Q3. Query all columns (attributes) for every row in the CITY table.

select * from city;
=============================================================================================================================================
Q4. Query all columns for a city in CITY with the ID 1661.
The CITY table is described as follows:

select * from city 
where ID=1661;
===================================================================================================================================================
Q5. Query all attributes of every Japanese city in the CITY table. The COUNTRYCODE for Japan is
JPN.
The CITY table is described as follows:


select *  from city
where COUNTRYCODE="JPN";
=========================================================================================================================================================
Q6. Query the names of all the Japanese cities in the CITY table. The COUNTRYCODE for Japan is
JPN.
The CITY table is described as follows:

select DISTRICT from city
where COUNTRYCODE="JPN";
======================================================================================================================================================
Q7. Query a list of CITY and STATE from the STATION table.
The STATION table is described as follows:

select city ,state from stationdata;
============================================================================================================================================
Q8. Query a list of CITY names from STATION for cities that have an even ID number. Print the results
in any order, but exclude duplicates from the answer.
The STATION table is described as follows:

select distinct(Id),city  from stationdata
where mod(Id,2)=0
order by Id;
============================================================================================================================================================
Q9. Find the difference between the total number of CITY entries in the table and the number of
distinct CITY entries in the table.
The STATION table is described as follows:

select count(city) - count(distinct(city)) as diff from stationdata;
======================================================================================================================================================
Q10. Query the two cities in STATION with the shortest and longest CITY names, as well as their
respective lengths (i.e.: number of characters in the name). If there is more than one smallest or
largest city, choose the one that comes first when ordered alphabetically.
The STATION table is described as follows:


select City ,length(City) as city_len from stationdata 
order by city_len;

select City ,length(City) as city_len from stationdata 
order by city_len desc;
===============================================================================================================================================
Q11. Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result
cannot contain duplicates.
Input Format
The STATION table is described as follows:



select distinct(City) from stationdata
where City regexp "^a|^e|^i|^o|^u"
order by City;
===============================================================================================================================================

Q12. Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot
contain duplicates.
Input Format
The STATION table is described as follows:

select distinct(City) from stationdata
where City regexp "a$|e$|i$|o$|u$"
order by City;

===============================================================================================================================================
Q13. Query the list of CITY names from STATION that do not start with vowels. Your result cannot
contain duplicates.
Input Format
The STATION table is described as follows:

select distinct(City) from stationdata
where not City regexp "^a|^e|^i|^o|^u"
order by City;
============================================================================================================================================
Q14. Query the list of CITY names from STATION that do not end with vowels. Your result cannot
contain duplicates.

Input Format
The STATION table is described as follows:


select distinct(City) from stationdata
where not City regexp "a$|e$|i$|o$|u$"
order by City;
=============================================================================================================================================
Q15. Query the list of CITY names from STATION that either do not start with vowels or do not end
with vowels. Your result cannot contain duplicates.
Input Format
The STATION table is described as follows:


select distinct(City) from stationdata
where not City regexp "a$|e$|i$|o$|u$|^a|^e|^i|^o|^u"
order by City;

select distinct(City) from stationdata
where upper(substr(City,1,1)) not in("A","E","I","O","U")  or 
lower(substr(City,-1,1)) not in("a","e","i","o","u")
order by City;
=========================================================================================================================================
Q16. Query the list of CITY names from STATION that do not start with vowels and do not end with
vowels. Your result cannot contain duplicates.

Input Format
The STATION table is described as follows:

select distinct(City) from stationdata
where not City regexp "a$|e$|i$|o$|u$|^a|^e|^i|^o|^u                                                                                                                                                                    "
order by City;


=====================================================================================================================================================================

Q17.
Table: Product

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
| unit_price   | int     |
+--------------+---------+
product_id is the primary key of this table.
Each row of this table indicates the name and the price of each product.
Table: Sales

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| seller_id   | int     |
| product_id  | int     |
| buyer_id    | int     |
| sale_date   | date    |
| quantity    | int     |
| price       | int     |
+-------------+---------+
This table has no primary key, it can have repeated rows.
product_id is a foreign key to the Product table.
Each row of this table contains some information about one sale.
Write an SQL query that reports the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.

Return the result table in any order.

The query result format is in the following example.

Example 1:

Input: 
Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+
Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+
Output: 
+-------------+--------------+
| product_id  | product_name |
+-------------+--------------+
| 1           | S8           |
+-------------+--------------+
Explanation: 
The product with id 1 was only sold in the spring of 2019.
The product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.
The product with id 3 was sold after spring 2019.
We return only product 1 as it is the product that was only sold in the spring of 2019.
-------------------------------------------------------------------------------------------------------------->


create table product(
product_id int primary key,
product_name varchar(20) ,
unit_price int);

create table sales(
seller_id int ,
product_id int,
buyer_id int,
sale_date date,
quantity int,
price int);
 
 
 insert into product values
 (1,"S8",1000),
 (2 ,"G4",800),(3,"iPhone",1400);
 
 select * from product;
 
 insert into sales values
 (1,1,1,"2019-01-21",2,2000),(1,2,2,"2019-02-17",1,800),(2,2,3,"2019-06-02",1,800),(3,3,4,"2019-05-13",2,2800);
 
 select * from sales;
 
 alter table sales 
 add foreign key (product_id)
 references product(product_id);
 
 select product.product_id,product.product_name, sales.sale_date from product
 left outer join
 sales
 on product.product_id=sales.product_id
 where sales.sale_date between "2019-01-01"  and "2019-03-31";


SELECT product_id, product_name FROM   product 
WHERE  product_id  not IN (SELECT product_id 
                          FROM   sales 
                          WHERE  sale_date  not BETWEEN 
                                 '2019-01-01' AND '2019-03-31');

===========================================================================================================================================

Q18.
Table: Views

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
There is no primary key for this table, it may have duplicate rows.
Each row of this table indicates that some viewer viewed an article (written by some author) on some date. 
Note that equal author_id and viewer_id indicate the same person.
Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id.

The query result format is in the following example:

Views table:
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+

Result table:
+------+
| id   |
+------+
| 4    |
| 7    |
+------+

------------------------------------------------------------------------------------------->

 create table views(
 article_id int,
 author_id int,
 viewer_id int,
 view_date date);
 
 insert into views values
 (1,3,5,"2019-08-01"),(1,3,6,"2019-08-02"),(2,7,7,"019-08-01"),(2,7,6,"2019-08-02"),(4,7,1,"2019-07-22"),
 (3,4,4,"2019-07-21"),(3,4,4,"2019-07-21");
 
 select * from views;
 
 select distinct(author_id) from views
 where author_id=viewer_id
 order by author_id;

=================================================================================================================================================================

Q19.
Table: Delivery

+-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+
| delivery_id                 | int     |
| customer_id                 | int     |
| order_date                  | date    |
| customer_pref_delivery_date | date    |
+-----------------------------+---------+
delivery_id is the primary key of this table.
The table holds information about food delivery to customers that make orders at some date and specify a preferred delivery date (on the same order date or after it).
If the preferred delivery date of the customer is the same as the order date then the order is called immediate otherwise itâ€™s called scheduled.

Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.

The query result format is in the following example:


Delivery table:
+-------------+-------------+------------+-----------------------------+
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
+-------------+-------------+------------+-----------------------------+
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 5           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-11                  |
| 4           | 3           | 2019-08-24 | 2019-08-26                  |
| 5           | 4           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
+-------------+-------------+------------+-----------------------------+

Result table:
+----------------------+
| immediate_percentage |
+----------------------+
| 33.33                |
+----------------------+
The orders with delivery id 2 and 3 are immediate while the others are scheduled.
---------------------------------------------------------------------------------------------------------------->

create table delivery(
delivery_id int primary key,
customer_id int,
order_date date,
customer_pref_delivery_date date);

insert into delivery values
(1,1,"2019-08-01","2019-08-02"),(2,5,"2019-08-02","2019-08-02"),
(3,1,"2019-08-11","2019-08-11"),(4,3,"2019-08-24","2019-08-26"),
(5,4,"2019-08-21","2019-08-22"),(6,2,"2019-08-11","2019-08-13");

select * from delivery;
select round(
            sum(case
                    when order_date=customer_pref_delivery_date  then 1
                    else 0 
                    end)/count(*)*100,2)
                                  as percentages
                                  from delivery;



===================================================================================================================================================================
Q20.
--Table: Ads
--
--+---------------+---------+
--| Column Name   | Type    |
--+---------------+---------+
--| ad_id         | int     |
--| user_id       | int     |
--| action        | enum    |
--+---------------+---------+
--(ad_id, user_id) is the primary key for this table.
--Each row of this table contains the ID of an Ad, the ID of a user and the action taken by this user regarding this Ad.
--The action column is an ENUM type of ('Clicked', 'Viewed', 'Ignored').
--
--
--A company is running Ads and wants to calculate the performance of each Ad.
--
--Performance of the Ad is measured using Click-Through Rate (CTR) where:
--
--
--
--Write an SQL query to find the ctr of each Ad.
--
--Round ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie.
--
--The query result format is in the following example:
--
--Ads table:
--+-------+---------+---------+
--| ad_id | user_id | action  |
--+-------+---------+---------+
--| 1     | 1       | Clicked |
--| 2     | 2       | Clicked |
--| 3     | 3       | Viewed  |
--| 5     | 5       | Ignored |
--| 1     | 7       | Ignored |
--| 2     | 7       | Viewed  |
--| 3     | 5       | Clicked |
--| 1     | 4       | Viewed  |
--| 2     | 11      | Viewed  |
--| 1     | 2       | Clicked |
--+-------+---------+---------+
--Result table:
--+-------+-------+
--| ad_id | ctr   |
--+-------+-------+
--| 1     | 66.67 |
--| 3     | 50.00 |
--| 2     | 33.33 |
--| 5     | 0.00  |
--+-------+-------+
--for ad_id = 1, ctr = (2/(2+1)) * 100 = 66.67
--for ad_id = 2, ctr = (1/(1+2)) * 100 = 33.33
--for ad_id = 3, ctr = (1/(1+1)) * 100 = 50.00
--for ad_id = 5, ctr = 0.00, Note that ad_id = 5 has no clicks or views.
--Note that we don't care about Ignored Ads.
--Result table is ordered by the ctr. in case of a tie we order them by ad_id


-------------------------------------------------------------------------------------->

create table ads(
ad_id int,
user_id int,
action varchar(20));

insert into ads
values
(1,1,'Clicked'),(2,2,'Clicked'),(3,3,'Viewed'),(5,5,'Ignored'),(1,7,'Ignored'),(2,7,'Viewed'),
(3,5,'Clicked'),(1,4,'Viewed'),(2,11,'Viewed'),(1,2,'Clicked');

select * from ads;

select
ad_id,round(avg(case when action='Clicked' then 1 
else 0 end)*100,2) as ctr
from ads
group by ad_id;
===============================================================================================================================================================

Q21.
Table: Employee
*+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| employee_id   | int     |
| team_id       | int     |
+---------------+---------+
employee_id is the primary key for this table.
Each row of this table contains the ID of each employee and their respective team.
Write an SQL query to find the team size of each of the employees.

Return result table in any order.

The query result format is in the following example:

Employee Table:
+-------------+------------+
| employee_id | team_id    |
+-------------+------------+
|     1       |     8      |
|     2       |     8      |
|     3       |     8      |
|     4       |     7      |
|     5       |     9      |
|     6       |     9      |
+-------------+------------+
Result table:
+-------------+------------+
| employee_id | team_size  |
+-------------+------------+
|     1       |     3      |
|     2       |     3      |
|     3       |     3      |
|     4       |     1      |
|     5       |     2      |
|     6       |     2      |
+-------------+------------+
Employees with Id 1,2,3 are part of a team with team_id = 8.
Employees with Id 4 is part of a team with team_id = 7.
Employees with Id 5,6 are part of a team with team_id = 9.*/

------------------------------------------------------------------------->

create table employee(
employee_id int primary key,
team_id int);

insert into employee values
(1,8),(2,8),(3,8),(4,7),(5,9),(6,9);

select * from employee;

select employee_id,
count(team_id)
over(partition by team_id ) 
as team_size
from employee
order by employee_id;



================================================================================================================================================================

Q22.
Table: Countries

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| country_id    | int     |
| country_name  | varchar |
+---------------+---------+
country_id is the primary key for this table.
Each row of this table contains the ID and the name of one country.
Table: Weather

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| country_id    | int     |
| weather_state | varchar |
| day           | date    |
+---------------+---------+
(country_id, day) is the primary key for this table.
Each row of this table indicates the weather state in a country for one day.
Write an SQL query to find the type of weather in each country for November 2019.

The type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise.

Return result table in any order.

The query result format is in the following example:

Countries table:
+------------+--------------+
| country_id | country_name |
+------------+--------------+
| 2          | USA          |
| 3          | Australia    |
| 7          | Peru         |
| 5          | China        |
| 8          | Morocco      |
| 9          | Spain        |
+------------+--------------+
Weather table:
+------------+---------------+------------+
| country_id | weather_state | day        |
+------------+---------------+------------+
| 2          | 15            | 2019-11-01 |
| 2          | 12            | 2019-10-28 |
| 2          | 12            | 2019-10-27 |
| 3          | -2            | 2019-11-10 |
| 3          | 0             | 2019-11-11 |
| 3          | 3             | 2019-11-12 |
| 5          | 16            | 2019-11-07 |
| 5          | 18            | 2019-11-09 |
| 5          | 21            | 2019-11-23 |
| 7          | 25            | 2019-11-28 |
| 7          | 22            | 2019-12-01 |
| 7          | 20            | 2019-12-02 |
| 8          | 25            | 2019-11-05 |
| 8          | 27            | 2019-11-15 |
| 8          | 31            | 2019-11-25 |
| 9          | 7             | 2019-10-23 |
| 9          | 3             | 2019-12-23 |
+------------+---------------+------------+
Result table:
+--------------+--------------+
| country_name | weather_type |
+--------------+--------------+
| USA          | Cold         |
| Austraila    | Cold         |
| Peru         | Hot          |
| China        | Warm         |
| Morocco      | Hot          |
+--------------+--------------+
Average weather_state in USA in November is (15) / 1 = 15 so weather type is Cold.
Average weather_state in Austraila in November is (-2 + 0 + 3) / 3 = 0.333 so weather type is Cold.
Average weather_state in Peru in November is (25) / 1 = 25 so weather type is Hot.
Average weather_state in China in November is (16 + 18 + 21) / 3 = 18.333 so weather type is Warm.
Average weather_state in Morocco in November is (25 + 27 + 31) / 3 = 27.667 so weather type is Hot.
We know nothing about average weather_state in Spain in November so we don't include it in the result table. 


--------------------------------------------------------------------------------------------------------------------->

create table country(
country_id int,
country_name varchar(20));

create table weather(
country_id int,
weather_state int,
day date);


alter table country 
add primary key (country_id);

alter table weather 
add primary key (country_id,day);


insert into country values
(2,"USA"),(3,"Australia"),(7,"Peru"),(5 ,"China"),(8,"Morocco"),(9,"Spain");

select * from country;

insert into weather values
(2 ,15,"2019-11-01"),(2,12,"2019-10-28");

insert into weather values
(2 ,12 ,"2019-10-27"),(3,-2 ,"2019-11-10"),(3,0,"2019-11-11"),(3,3,"2019-11-12"),
(5,16,"2019-11-07"),(5,18,"2019-11-09"),(5,21,"2019-11-23"),(7,25,"2019-11-28"),
(7 ,22,"2019-12-01"),(7,20,"2019-12-02"),(8 ,25,"2019-11-05"),(8,27,"2019-11-15"),
(8,31,"2019-11-25"),(9, 7 ,"2019-10-23"),(9,3,"2019-12-23");

select * from weather;

select c.country_name,
case 
when avg(weather_state) <=15 then "cold"
when avg(weather_state) >=25 then "hot"
else "warm" end as weather_type
from weather as w
left join
country as c
on c.country_id=w.country_id
where month(day)=11 and year(day)=2019
group by w.country_id
order by weather_type;
===============================================================================================================================================================
Q23.
Table: Prices

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| start_date    | date    |
| end_date      | date    |
| price         | int     |
+---------------+---------+
(product_id, start_date, end_date) is the primary key for this table.
Each row of this table indicates the price of the product_id in the period from start_date to end_date.
For each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.
Table: UnitsSold

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| purchase_date | date    |
| units         | int     |
+---------------+---------+
There is no primary key for this table, it may contain duplicates.
Each row of this table indicates the date, units and product_id of each product sold. 
Write an SQL query to find the average selling price for each product.

average_price should be rounded to 2 decimal places.

The query result format is in the following example:

Prices table:

+------------+------------+------------+--------+
| product_id | start_date | end_date   | price  |
+------------+------------+------------+--------+
| 1          | 2019-02-17 | 2019-02-28 | 5      |
| 1          | 2019-03-01 | 2019-03-22 | 20     |
| 2          | 2019-02-01 | 2019-02-20 | 15     |
| 2          | 2019-02-21 | 2019-03-31 | 30     |
+------------+------------+------------+--------+
UnitsSold table:

+------------+---------------+-------+
| product_id | purchase_date | units |
+------------+---------------+-------+
| 1          | 2019-02-25    | 100   |
| 1          | 2019-03-01    | 15    |
| 2          | 2019-02-10    | 200   |
| 2          | 2019-03-22    | 30    |
+------------+---------------+-------+
Result table:

+------------+---------------+
| product_id | average_price |
+------------+---------------+
| 1          | 6.96          |
| 2          | 16.96         |
+------------+---------------+
Average selling price = Total Price of Product / Number of products sold.
Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96
Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96
----------------------------------------------------------------------------------------->
create table prices (
product_id int,
start_date date,
end_date date,
price int);

alter table prices
add primary key (product_id, start_date, end_date);

create table UnitsSold(
product_id int,
purchase_date date,
units int);

insert into prices values
(1 ,"2019-02-17" ,"2019-02-28" ,5),(1 ,"2019-03-01","2019-03-22 ",20),
(2 ,"2019-02-01" ,"2019-02-20 ",15),(2 ,"2019-02-21 ","2019-03-31",30);

select * from prices;

insert into UnitsSold values
(1 ,"2019-02-25",100),(1 ,"2019-03-01",15),(2,"2019-02-10",200),(2,"2019-03-22",30);

select * from UnitsSold ;




select p.product_id , round(sum(p.price*u.units)/sum(u.units),2) as avg_price
from prices as p
join
UnitsSold as u
on p.product_id=u.product_id
where u.purchase_date between p.start_date and p.end_date
group by p.product_id;

=================================================================================================================================================================
Q24.
Table: Activity

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.
Write an SQL query that reports the first login date for each player.

The query result format is in the following example:

Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
Result table:
+-----------+-------------+
| player_id | first_login |
+-----------+-------------+
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |
+-----------+-------------+
---------------------------------------------------------------------------------->

create table activity(
player_id int,
device_id int,
event_date date,
games_played int);

insert into activity values
(1,2,"2016-03-01", 5),(1,2 ,"2016-05-02",6),(2 ,3,"2017-06-25",1),(3, 1,"2016-03-02", 0),(3 ,4 ,"2018-07-03",5);

alter table activity 
add primary key (player_id, event_date);

select * from activity;

select player_id,min(event_date) start_date from activity 
group by player_id;

select player_id,event_date from
(select player_id,event_date,
row_number()
over(partition by player_id) as start_date
from activity) as x
where x.start_date=1;
===================================================================================================================================================
Q25.
Table: Activity

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.
Write an SQL query that reports the first login date for each player.

The query result format is in the following example:

Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
Result table:
+-----------+-------------+
| player_id | first_login |
+-----------+-------------+
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |
+-----------+-------------+
-------------------------------------------------------------------------------->
create table activity(
player_id int,
device_id int,
event_date date,
games_played int);
alter table activity
add primary key (player_id, event_date);

insert into activity values
(1,2,"2016-03-01",5),(1,2,"2016-05-02",6),(2,3,"2017-06-25",1),(3,1,"2016-03-02",0),(3,4,"2018-07-03",5);

select device_id,event_date as first_login from
(select *,
rank()
over(partition by player_id order by event_date) as rnk
from activity) x
where rnk=1;
========================================================================================================================================

Q26.
--Table: Products
--
--+------------------+---------+
--| Column Name      | Type    |
--+------------------+---------+
--| product_id       | int     |
--| product_name     | varchar |
--| product_category | varchar |
--+------------------+---------+
--product_id is the primary key for this table.
--This table contains data about the company's products.
--Table: Orders
--
--+---------------+---------+
--| Column Name   | Type    |
--+---------------+---------+
--| product_id    | int     |
--| order_date    | date    |
--| unit          | int     |
--+---------------+---------+
--There is no primary key for this table. It may have duplicate rows.
--product_id is a foreign key to Products table.
--unit is the number of products ordered in order_date.
--
--
--Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.
--
--Return result table in any order.
--
--The query result format is in the following example:
--
--
--
--Products table:
--+-------------+-----------------------+------------------+
--| product_id  | product_name          | product_category |
--+-------------+-----------------------+------------------+
--| 1           | Leetcode Solutions    | Book             |
--| 2           | Jewels of Stringology | Book             |
--| 3           | HP                    | Laptop           |
--| 4           | Lenovo                | Laptop           |
--| 5           | Leetcode Kit          | T-shirt          |
--+-------------+-----------------------+------------------+
--
--Orders table:
--+--------------+--------------+----------+
--| product_id   | order_date   | unit     |
--+--------------+--------------+----------+
--| 1            | 2020-02-05   | 60       |
--| 1            | 2020-02-10   | 70       |
--| 2            | 2020-01-18   | 30       |
--| 2            | 2020-02-11   | 80       |
--| 3            | 2020-02-17   | 2        |
--| 3            | 2020-02-24   | 3        |
--| 4            | 2020-03-01   | 20       |
--| 4            | 2020-03-04   | 30       |
--| 4            | 2020-03-04   | 60       |
--| 5            | 2020-02-25   | 50       |
--| 5            | 2020-02-27   | 50       |
--| 5            | 2020-03-01   | 50       |
--+--------------+--------------+----------+
--
--Result table:
--+--------------------+---------+
--| product_name       | unit    |
--+--------------------+---------+
--| Leetcode Solutions | 130     |
--| Leetcode Kit       | 100     |
--+--------------------+---------+
--
--Products with product_id = 1 is ordered in February a total of (60 + 70) = 130.
--Products with product_id = 2 is ordered in February a total of 80.
--Products with product_id = 3 is ordered in February a total of (2 + 3) = 5.
--Products with product_id = 4 was not ordered in February 2020.
--Products with product_id = 5 is ordered in February a total of (50 + 50) = 100.
------------------------------------------------------------------------------------------>

create table product1(
product_id int,
product_name varchar(20),
product_category varchar(20));

create table order1 (
product_id int,
order_date date,
unit int);

alter table product1
add primary key(product_id);

alter table product1
modify column product_name varchar(100);
insert into product1 values
(1 ,"Leetcode Solutions" ,"Book"),(2,"Jewels of Stringology","Book"),(3 ,"HP ","Laptop"),
(4 ,"Lenovo","Laptop"),(5 ,"Leetcode Kit" ,"T-shirt");

select * from product1;

insert into order1 values
(1,"2020-02-05",60),(1,"2020-02-10", 70),(2,"2020-01-18", 30),(3,"2020-02-17",2),(3,"2020-02-24", 3),
(4,"2020-03-01",20),(4,"2020-03-04 ",30),(4, '2020-03-04', 60),
(5," 2020-02-25",50),(5 ,"2020-02-27", 50),(5 ,"2020-03-01", 50);

select * from order1;

select p.product_name,sum(o.unit) as total
 from product1  p
 left join order1  o
 on p.product_id=o.product_id
 where month(order_date)=2 and year (order_date)=2020
 group by o.product_id
 having total>=100;
 =========================================================================================================================================================

Q27.
Table: Users

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| name          | varchar |
| mail          | varchar |
+---------------+---------+
user_id is the primary key for this table.
This table contains information of the users signed up in a website. Some e-mails are invalid.
 

Write an SQL query to find the users who have valid emails.

A valid e-mail has a prefix name and a domain where: 

The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.' and/or dash '-'. The prefix name must start with a letter.
The domain is '@leetcode.com'.
Return the result table in any order.

The query result format is in the following example.

 

Users
+---------+-----------+-------------------------+
| user_id | name      | mail                    |
+---------+-----------+-------------------------+
| 1       | Winston   | winston@leetcode.com    |
| 2       | Jonathan  | jonathanisgreat         |
| 3       | Annabelle | bella-@leetcode.com     |
| 4       | Sally     | sally.come@leetcode.com |
| 5       | Marwan    | quarz#2020@leetcode.com |
| 6       | David     | david69@gmail.com       |
| 7       | Shapiro   | .shapo@leetcode.com     |
+---------+-----------+-------------------------+

Result table:
+---------+-----------+-------------------------+
| user_id | name      | mail                    |
+---------+-----------+-------------------------+
| 1       | Winston   | winston@leetcode.com    |
| 3       | Annabelle | bella-@leetcode.com     |
| 4       | Sally     | sally.come@leetcode.com |
+---------+-----------+-------------------------+
The mail of user 2 doesn't have a domain.
The mail of user 5 has # sign which is not allowed.
The mail of user 6 doesn't have leetcode domain.
The mail of user 7 starts with a period.l
.com

------------------------------------->

create table users (
user_id int,
name varchar(20),
mail varchar(30));

alter table users
add primary key (user_id);

insert into users values
(1,"Winston","winston@leetcode.com"),(2 ,"Jonathan ","jonathanisgreat"),
(3 ,"Annabelle","bella-@leetcode.com"),(4 ,"Sally","sally.come@leetcode.com"),
(5 ,"Marwan","quarz#2020@leetcode.com"),(6 ,"David","david69@gmail.com"),(7 ,"Shapiro" ,".shapo@leetcode.com");

select * from users;

select * from users
where mail regexp "^[a-zA-Z][a-zA-Z0-9,-_.]+@leetcode[.]com";

select * from users
where mail regexp "^[a-zA-Z][a-zA-Z0-9,-_.]*@leetcode[.]com";

select * from users
where mail regexp "^[a-zA-Z][a-zA-Z0-9,-_.]{0,}@leetcode[.]com";

select * from users
where mail regexp "^[a-zA-Z][a-zA-Z0-9,-_.]{0,}@leetcode.com$";
==============================================================================================================================================
Q28.
Table: Customers

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
| country       | varchar |
+---------------+---------+
customer_id is the primary key for this table.
This table contains information of the customers in the company.
Table: Product

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| description   | varchar |
| price         | int     |
+---------------+---------+
product_id is the primary key for this table.
This table contains information of the products in the company.
price is the product cost.
Table: Orders

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| customer_id   | int     |
| product_id    | int     |
| order_date    | date    |
| quantity      | int     |
+---------------+---------+
order_id is the primary key for this table.
This table contains information on customer orders.
customer_id is the id of the customer who bought "quantity" products with id "product_id".
Order_date is the date in format ('YYYY-MM-DD') when the order was shipped.
Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020.

Return the result table in any order.

The query result format is in the following example.

Customers
+--------------+-----------+-------------+
| customer_id  | name      | country     |
+--------------+-----------+-------------+
| 1            | Winston   | USA         |
| 2            | Jonathan  | Peru        |
| 3            | Moustafa  | Egypt       |
+--------------+-----------+-------------+

Product
+--------------+-------------+-------------+
| product_id   | description | price       |
+--------------+-------------+-------------+
| 10           | LC Phone    | 300         |
| 20           | LC T-Shirt  | 10          |
| 30           | LC Book     | 45          |
| 40           | LC Keychain | 2           |
+--------------+-------------+-------------+

Orders
+--------------+-------------+-------------+-------------+-----------+
| order_id     | customer_id | product_id  | order_date  | quantity  |
+--------------+-------------+-------------+-------------+-----------+
| 1            | 1           | 10          | 2020-06-10  | 1         |
| 2            | 1           | 20          | 2020-07-01  | 1         |
| 3            | 1           | 30          | 2020-07-08  | 2         |
| 4            | 2           | 10          | 2020-06-15  | 2         |
| 5            | 2           | 40          | 2020-07-01  | 10        |
| 6            | 3           | 20          | 2020-06-24  | 2         |
| 7            | 3           | 30          | 2020-06-25  | 2         |
| 9            | 3           | 30          | 2020-05-08  | 3         |
+--------------+-------------+-------------+-------------+-----------+

Result table:
+--------------+------------+
| customer_id  | name       |  
+--------------+------------+
| 1            | Winston    |
+--------------+------------+ 
Winston spent $300 (300 * 1) in June and $100 ( 10 * 1 + 45 * 2) in July 2020.
Jonathan spent $600 (300 * 2) in June and $20 ( 2 * 10) in July 2020.
Moustafa spent $110 (10 * 2 + 45 * 2) in June and $0 in July 2020..

-------------------------------------------------------------------------------------------------->

create table customers(
customer_id int primary key,
name varchar (30),
country varchar(20) 
);

create table product3 (
product_id int primary key,
description varchar (25),
price int);

create table orders(
order_id int primary key,
customer_id int,
product_id int,
order_date date,
quantity int);

insert into customers values
(1," Winston" ,"USA"),(2, "Jonathan","Peru"),(3 ,"Moustafa" ,"Egypt");

insert into product3 values
(10 ,"LC Phone" ,300),(20 ,"LC T-Shirt",10),(30 ,"LC Book",45),(40 ,"LC Keychain" ,2);

select * from product3;

select * from customers;

insert into orders values
(1 ,1 ,10 ,"2020-06-10", 1),(2, 1, 20 ,"2020-07-01", 1),(3, 1 ,30 ,"2020-07-08",2),
(4 ,2 ,10, "2020-06-15", 2),(5, 2 ,40, "2020-07-01",10),(6, 3, 20 ,"2020-06-24" ,2),
(7, 3 ,30 ,"2020-06-25", 2),(9 ,3 ,30 ,"2020-05-08" ,3);

select * from orders;

select x.name as name ,x.customer_id as  customer_id from
(select o.customer_id ,c.name, sum(price*quantity) as spend
from customers c
join 
orders o
on c.customer_id =o.customer_id 
join 
product3 p
on o.product_id=p.product_id 
where  month(order_date) in (6,7) and year(order_date)=2020
group by customer_id,month(order_date)
having spend>=100 ) x
group by x.customer_id,x.name
having count(*)=2;
======================================================================================================================================================
Q29.
Table: TVProgram

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| program_date  | date    |
| content_id    | int     |
| channel       | varchar |
+---------------+---------+
(program_date, content_id) is the primary key for this table.
This table contains information of the programs on the TV.
content_id is the id of the program in some channel on the TV.
Table: Content


+------------------+---------+
| Column Name      | Type    |
+------------------+---------+
| content_id       | varchar |
| title            | varchar |
| Kids_content     | enum    |
| content_type     | varchar |
+------------------+---------+
content_id is the primary key for this table.
Kids_content is an enum that takes one of the values ('Y', 'N') where: 
'Y' means is content for kids otherwise 'N' is not content for kids.
content_type is the category of the content as movies, series, etc.
Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.

Return the result table in any order.

The query result format is in the following example.


TVProgram table:
+--------------------+--------------+-------------+
| program_date       | content_id   | channel     |
+--------------------+--------------+-------------+
| 2020-06-10 08:00   | 1            | LC-Channel  |
| 2020-05-11 12:00   | 2            | LC-Channel  |
| 2020-05-12 12:00   | 3            | LC-Channel  |
| 2020-05-13 14:00   | 4            | Disney Ch   |
| 2020-06-18 14:00   | 4            | Disney Ch   |
| 2020-07-15 16:00   | 5            | Disney Ch   |
+--------------------+--------------+-------------+

Content table:
+------------+----------------+---------------+---------------+
| content_id | title          | Kids_content  | content_type  |
+------------+----------------+---------------+---------------+
| 1          | Leetcode Movie | N             | Movies        |
| 2          | Alg. for Kids  | Y             | Series        |
| 3          | Database Sols  | N             | Series        |
| 4          | Aladdin        | Y             | Movies        |
| 5          | Cinderella     | Y             | Movies        |
+------------+----------------+---------------+---------------+

Result table:
+--------------+
| title        |
+--------------+
| Aladdin      |
+--------------+
"Leetcode Movie" is not a content for kids.
"Alg. for Kids" is not a movie.
"Database Sols" is not a movie
"Alladin" is a movie, content for kids and was streamed in June 2020.
"Cinderella" was not streamed in June 2020.

------------------------------------------------------------------------------>
create table tvprogram(
program_date date,
content_id int,
channel varchar(20));
alter table tvprogram
add primary key (program_date, content_id);

create table content (
content_id int,
title varchar(30),
Kids_content varchar(20),
content_type varchar(20));

alter table content 
add primary key (content_id);

alter table tvprogram
modify column program_date datetime;

insert into tvprogram values
("2020-06-10 08:00",1,"LC-Channel"),("2020-05-11 12:00",2,"LC-Channel"),
("2020-05-12 12:00",3, "LC-Channel"),("2020-05-13 14:00",4,"Disney Ch"),
("2020-06-18 14:00",4,"Disney Ch"),("2020-07-15 16:00",5,"Disney Ch");
select * from tvprogram;


insert into content values
(1,"Leetcode Movie","N","Movies"),(2,"Alg. for Kids","Y","Series"),
(3,"Database Sols","N","Series"),(4,"Aladdin","Y","Movies"),(5,"Cinderella","Y","Movies");

select  * from content; 



select distinct(title) from tvprogram as t
join 
content c
on t.content_id=c.content_id
where month(program_date)=6 and year(program_date)=2020 
and Kids_content="y";
==================================================================================================================================================
Q30.

Table: NPV

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| year          | int     |
| npv           | int     |
+---------------+---------+
(id, year) is the primary key of this table.
The table has information about the id and the year of each inventory and the corresponding net present value.
 

Table: Queries

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| year          | int     |
+---------------+---------+
(id, year) is the primary key of this table.
The table has information about the id and the year of each inventory query.
 

Write an SQL query to find the npv of all each query of queries table.

Return the result table in any order.

The query result format is in the following example:

NPV table:
+------+--------+--------+
| id   | year   | npv    |
+------+--------+--------+
| 1    | 2018   | 100    |
| 7    | 2020   | 30     |
| 13   | 2019   | 40     |
| 1    | 2019   | 113    |
| 2    | 2008   | 121    |
| 3    | 2009   | 12     |
| 11   | 2020   | 99     |
| 7    | 2019   | 0      |
+------+--------+--------+

Queries table:
+------+--------+
| id   | year   |
+------+--------+
| 1    | 2019   |
| 2    | 2008   |
| 3    | 2009   |
| 7    | 2018   |
| 7    | 2019   |
| 7    | 2020   |
| 13   | 2019   |
+------+--------+

Result table:
+------+--------+--------+
| id   | year   | npv    |
+------+--------+--------+
| 1    | 2019   | 113    |
| 2    | 2008   | 121    |
| 3    | 2009   | 12     |
| 7    | 2018   | 0      |
| 7    | 2019   | 0      |
| 7    | 2020   | 30     |
| 13   | 2019   | 40     |
+------+--------+--------+

The npv value of (7, 2018) is not present in the NPV table, we consider it 0.
The npv values of all other queries can be found in the NPV table.



----------------------------------------------------------------------------------------->
create table npv(
id int,
year int,
npv int);
alter table npv
add primary key (id, year);

create table queries(
id int,
year int);

alter table queries
add primary key (id, year);

insert into npv values
(1,2018,100),(7,2020,30),(13,2019,40),(1,2019,113),(2,2008,121),(3,2009,12),(11,2020,99),(7,2019,0);
select * from npv;


insert into queries values
(1,2019),(2,2008),(3,2009),(7,2018),(7,2019),(7,2020),(13,2019);

select * from queries;

select q.id,q.year  ,
case when n.npv is null then 0
else n.npv
end as npv
from queries q
left join 
npv n
on (q.id,q.year)=(n.id,n.year);
=========================================================================================================================================================
Q32.
Table: Employees

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
+---------------+---------+
id is the primary key for this table.
Each row of this table contains the id and the name of an employee in a company.
Table: EmployeeUNI


+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| unique_id     | int     |
+---------------+---------+
(id, unique_id) is the primary key for this table.
Each row of this table contains the id and the corresponding unique id of an employee in the company.
Write an SQL query to show the unique ID of each user. If a user doesnâ€™t have a unique ID replace just show null.

Return the result table in any order.

The query result format is in the following example:


Employees table:
+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+

EmployeeUNI table:
+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+

EmployeeUNI table:
+-----------+----------+
| unique_id | name     |
+-----------+----------+
| null      | Alice    |
| null      | Bob      |
| 2         | Meir     |
| 3         | Winston  |
| 1         | Jonathan |
+-----------+----------+

Alice and Bob don't have a unique ID, We will show null instead.
The unique ID of Meir is 2.
The unique ID of Winston is 3.
The unique ID of Jonathan is 1.
--------------------------------------------------------------------------------->
create table user1(
id int,
name varchar(30));
alter table user1
add primary key(id);

create table rides (
id int primary key,
user_id int,
distance int);
insert into user1 values
(1,"Alice"),(2,"Bob"),(3,"Alex"),(4,"Donald"),(7,"Lee"),(13,"Jonathan"),(19,"Elvis");

select * from user1;

insert into rides values
(1,1,120),(2,2,317),(3,3,222),(4,7,100),(5,13,312),(6,19,50),(7,7,120),(8,19,400),(9,7,230);

select * from rides;

select x.name as name  ,
case
when x.travelled_dis is not null then x.travelled_dis 
else 0
end as travelled_distance 
from(
select name,sum(distance) as travelled_dis 
from user1 u
left join
rides r 
on u.id=r.user_id
group by name
order by travelled_dis desc) x;
=====================================================================================================================================================
Q34.

--Table: Products
--
--+------------------+---------+
--| Column Name      | Type    |
--+------------------+---------+
--| product_id       | int     |
--| product_name     | varchar |
--| product_category | varchar |
--+------------------+---------+
--product_id is the primary key for this table.
--This table contains data about the company's products.
--Table: Orders
--
--+---------------+---------+
--| Column Name   | Type    |
--+---------------+---------+
--| product_id    | int     |
--| order_date    | date    |
--| unit          | int     |
--+---------------+---------+
--There is no primary key for this table. It may have duplicate rows.
--product_id is a foreign key to Products table.
--unit is the number of products ordered in order_date.
--
--
--Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.
--
--Return result table in any order.
--
--The query result format is in the following example:
--
--
--
--Products table:
--+-------------+-----------------------+------------------+
--| product_id  | product_name          | product_category |
--+-------------+-----------------------+------------------+
--| 1           | Leetcode Solutions    | Book             |
--| 2           | Jewels of Stringology | Book             |
--| 3           | HP                    | Laptop           |
--| 4           | Lenovo                | Laptop           |
--| 5           | Leetcode Kit          | T-shirt          |
--+-------------+-----------------------+------------------+
--
--Orders table:
--+--------------+--------------+----------+
--| product_id   | order_date   | unit     |
--+--------------+--------------+----------+
--| 1            | 2020-02-05   | 60       |
--| 1            | 2020-02-10   | 70       |
--| 2            | 2020-01-18   | 30       |
--| 2            | 2020-02-11   | 80       |
--| 3            | 2020-02-17   | 2        |
--| 3            | 2020-02-24   | 3        |
--| 4            | 2020-03-01   | 20       |
--| 4            | 2020-03-04   | 30       |
--| 4            | 2020-03-04   | 60       |
--| 5            | 2020-02-25   | 50       |
--| 5            | 2020-02-27   | 50       |
--| 5            | 2020-03-01   | 50       |
--+--------------+--------------+----------+
--
--Result table:
--+--------------------+---------+
--| product_name       | unit    |
--+--------------------+---------+
--| Leetcode Solutions | 130     |
--| Leetcode Kit       | 100     |
--+--------------------+---------+
--
--Products with product_id = 1 is ordered in February a total of (60 + 70) = 130.
--Products with product_id = 2 is ordered in February a total of 80.
--Products with product_id = 3 is ordered in February a total of (2 + 3) = 5.
--Products with product_id = 4 was not ordered in February 2020.
--Products with product_id = 5 is ordered in February a total of (50 + 50) = 100.

---------------------------------------------------------------------------------->
create table products(
product_id int,
product_name varchar(40),
product_category varchar(20));

alter table products 
add primary key (product_id);

insert into products values
(1,"Leetcode Solutions","Book"),(2,"Jewels of Stringology","Book"),(3,"HP","Laptop"),
(4,"Lenovo","Laptop"),(5,"Leetcode Kit","T-shirt");

select * from products;

create table order2(
product_id int,
order_date date,
unit int);

insert into order2 values
(1,"2020-02-05",60 ),(1,"2020-02-10",70),(2,"2020-01-18",30 ),(2,"2020-02-11",80),
(3,"2020-02-17",2),(3,"2020-02-24",3),(4,"2020-03-01",20),(4,"2020-03-04",30),
(4,"2020-03-04",0),(5,"2020-02-25",50),( 5,"2020-02-27",50),(5,"2020-03-01",50);

select * from order2;

select product_name,sum(unit)  as unit
from products p
left join 
order2 o
on p.product_id=o.product_id
where month (order_date)=2
group by product_name
having unit >=100;
========================================================================================================================================================
Q35.

Movie Rating
--
--Table: Movies
--
--+---------------+---------+
--| Column Name   | Type    |
--+---------------+---------+
--| movie_id      | int     |
--| title         | varchar |
--+---------------+---------+
--movie_id is the primary key for this table.
--title is the name of the movie.
--Table: Users
--
--+---------------+---------+
--| Column Name   | Type    |
--+---------------+---------+
--| user_id       | int     |
--| name          | varchar |
--+---------------+---------+
--user_id is the primary key for this table.
--Table: Movie_Rating
--
--+---------------+---------+
--| Column Name   | Type    |
--+---------------+---------+
--| movie_id      | int     |
--| user_id       | int     |
--| rating        | int     |
--| created_at    | date    |
--+---------------+---------+
--(movie_id, user_id) is the primary key for this table.
--This table contains the rating of a movie by a user in their review.
--created_at is the user's review date.
--
--
--Write the following SQL query:
--
--Find the name of the user who has rated the greatest number of the movies.
--In case of a tie, return lexicographically smaller user name.
--
--Find the movie name with the highest average rating as of Feb 2020.
--In case of a tie, return lexicographically smaller movie name..
--
--Query is returned in 2 rows, the query result format is in the folowing example:
--
--Movie table:
--+-------------+--------------+
--| movie_id    |  title       |
--+-------------+--------------+
--| 1           | Avengers     |
--| 2           | Frozen 2     |
--| 3           | Joker        |
--+-------------+--------------+
--
--Users table:
--+-------------+--------------+
--| user_id     |  name        |
--+-------------+--------------+
--| 1           | Daniel       |
--| 2           | Monica       |
--| 3           | Maria        |
--| 4           | James        |
--+-------------+--------------+
--
--Movie_Rating table:
--+-------------+--------------+--------------+-------------+
--| movie_id    | user_id      | rating       | created_at  |
--+-------------+--------------+--------------+-------------+
--| 1           | 1            | 3            | 2020-01-12  |
--| 1           | 2            | 4            | 2020-02-11  |
--| 1           | 3            | 2            | 2020-02-12  |
--| 1           | 4            | 1            | 2020-01-01  |
--| 2           | 1            | 5            | 2020-02-17  |
--| 2           | 2            | 2            | 2020-02-01  |
--| 2           | 3            | 2            | 2020-03-01  |
--| 3           | 1            | 3            | 2020-02-22  |
--| 3           | 2            | 4            | 2020-02-25  |
--+-------------+--------------+--------------+-------------+
--
--Result table:
--+--------------+
--| results      |
--+--------------+
--| Daniel       |
--| Frozen 2     |
--+--------------+
--
--Daniel and Maria have rated 3 movies ("Avengers", "Frozen 2" and "Joker") but Daniel is smaller lexicographically.
--Frozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically.
------------------------------------------------------------------------------------------------------------------------------>

create table movies
(movie_id int,
title varchar(40)
);



alter table movies
add primary key (movie_id );
 insert into movies values
 (1,"Avengers"),(2,'Frozen 2'),(3,"Joker");
 
 select * from movies;
 
 create table users1(
 user_id int,
name varchar(20));
alter table users1
add primary key(user_id);

insert into users1 values
(1,"Daniel"),(2,"Monica"),(3,"Maria"),(4,"James");
 
 select * from users1;
 
 create table movie_rating(
 movie_id int,
user_id int,
rating int,
created_at date);

alter table movie_rating 
add primary key (movie_id, user_id);

insert into movie_rating values
(1,1,3,"2020-01-12"),(1,2,4,"2020-02-11"),(1,3,2,"2020-02-12"),
(1,4,1,"2020-01-01"),(2,1,5,"2020-02-17"),(2,2,2,"2020-02-01"),(2,3,2,"2020-03-01"),(3,1,3,"2020-02-22"),
(3,2,4,"2020-02-25");

select * from movie_rating;

select name as result from
(select name ,count(*) as ct from movie_rating mr
right join
users1 u
on mr.user_id=u.user_id
group by name
order by ct desc
limit 1) x
union
select title as result from
(select title, avg(rating) as avg from movie_rating mr
join
movies m
on m.movie_id=mr.movie_id
where month(created_at)=2 and  year(created_at)=2020
group by mr.movie_id
order by avg 
limit 1,1) y;
=================================================================================================================================================

Q37.
Table: Employees

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
+---------------+---------+
id is the primary key for this table.
Each row of this table contains the id and the name of an employee in a company.
 

Table: EmployeeUNI

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| unique_id     | int     |
+---------------+---------+
(id, unique_id) is the primary key for this table.
Each row of this table contains the id and the corresponding unique id of an employee in the company.
 

Write an SQL query to show the unique ID of each user, If a user doesn't have a unique ID replace just show null.

Return the result table in any order.

The query result format is in the following example:

Employees table:
+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+

EmployeeUNI table:
+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+

EmployeeUNI table:
+-----------+----------+
| unique_id | name     |
+-----------+----------+
| null      | Alice    |
| null      | Bob      |
| 2         | Meir     |
| 3         | Winston  |
| 1         | Jonathan |
+-----------+----------+

Alice and Bob don't have a unique ID, We will show null instead.
The unique ID of Meir is 2.
The unique ID of Winston is 3.
The unique ID of Jonathan is 1
------------------------------------------------------------------------------->

create table employee(
id int primary key ,
name varchar(30));

create table employeeuni(
id int,
unique_id int);

alter table employeeuni
add primary key (id, unique_id);

insert into employee values
(1,"Alice"),(7,"Bob"),(11,"Meir"),(90,"Winston"),(3,"Jonathan");

select * from employee;

insert into employeeuni values
(3,1),(11,2),(90,3);

select * from employeeuni;

select name , unique_id from employee e
left join
employeeuni eu
on e.id=eu.id
order by eu.unique_id;
===================================================================================================================================================
Q38.

Table: Departments

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
+---------------+---------+
id is the primary key of this table.
The table has information about the id of each department of a university.
 

Table: Students

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
| department_id | int     |
+---------------+---------+
id is the primary key of this table.
The table has information about the id of each student at a university and the id of the department he/she studies at.
 

Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.

Return the result table in any order.

The query result format is in the following example:

Departments table:
+------+--------------------------+
| id   | name                     |
+------+--------------------------+
| 1    | Electrical Engineering   |
| 7    | Computer Engineering     |
| 13   | Bussiness Administration |
+------+--------------------------+

Students table:
+------+----------+---------------+
| id   | name     | department_id |
+------+----------+---------------+
| 23   | Alice    | 1             |
| 1    | Bob      | 7             |
| 5    | Jennifer | 13            |
| 2    | John     | 14            |
| 4    | Jasmine  | 77            |
| 3    | Steve    | 74            |
| 6    | Luis     | 1             |
| 8    | Jonathan | 7             |
| 7    | Daiana   | 33            |
| 11   | Madelynn | 1             |
+------+----------+---------------+

Result table:
+------+----------+
| id   | name     |
+------+----------+
| 2    | John     |
| 7    | Daiana   |
| 4    | Jasmine  |
| 3    | Steve    |
+------+----------+

John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively.
 department 14, 33, 74 and 77 doesn't exist in the Departments table.

---------------------------------------------------------------------------------------------------------------------------------------->

create table dept(
id int primary key ,
name varchar(30));

create table student (
id int primary key,
name varchar (30),
department_id int);

insert into dept values
(1,"Electrical Engineering"),(7,"Computer Engineering"),(13,"Business Administration");

select * from dept;

insert into student values
(23,"Alice",1),(1,"Bob",7),(5,"Jennifer",13),(2,"John",14),(4,"Jasmine",77),
(3,"Steve",74),(6,"Luis",1),(8,"Jonathan",7),(7,"Daiana",33),(11,"Madelynn",1);

select * from student;

select s.id ,s.name from student s
left join
dept d
on s.department_id=d.id
where d.id is null;
=================================================================================================================================
Q39.
Table: Calls

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| from_id     | int     |
| to_id       | int     |
| duration    | int     |
+-------------+---------+
This table does not have a primary key, it may contain duplicates.
This table contains the duration of a phone call between from_id and to_id.
from_id != to_id
Write an SQL query to report the number of calls and the total call duration between each pair of distinct persons (person1, person2) where person1 < person2.

Return the result table in any order.

The query result format is in the following example:

Calls table:
+---------+-------+----------+
| from_id | to_id | duration |
+---------+-------+----------+
| 1       | 2     | 59       |
| 2       | 1     | 11       |
| 1       | 3     | 20       |
| 3       | 4     | 100      |
| 3       | 4     | 200      |
| 3       | 4     | 200      |
| 4       | 3     | 499      |
+---------+-------+----------+

Result table:
+---------+---------+------------+----------------+
| person1 | person2 | call_count | total_duration |
+---------+---------+------------+----------------+
| 1       | 2       | 2          | 70             |
| 1       | 3       | 1          | 20             |
| 3       | 4       | 4          | 999            |
+---------+---------+------------+----------------+
Users 1 and 2 had 2 calls and the total duration is 70 (59 + 11).
Users 1 and 3 had 1 call and the total duration is 20.
Users 3 and 4 had 4 calls and the total duration is 999 (100 + 200 + 200 + 499).
--------------------------------------------------------------------------------------------->


create table calls (
from_id int,
to_id int,
duration int);

insert into calls values
(1,2,59),(2,1,11),(1,3,20),(3,4,100),(3,4,200),(3,4,200),(4,3,499);

select * from calls;

select 
least(to_id,from_id) as person1,
greatest(to_id,from_id) as person2,
count(*) as call_count,
sum(duration) as total_duration
from calls
group by person1,person2;
=========================================================================================================================
Q40.
Table: Prices

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| start_date    | date    |
| end_date      | date    |
| price         | int     |
+---------------+---------+
(product_id, start_date, end_date) is the primary key for this table.
Each row of this table indicates the price of the product_id in the period from start_date to end_date.
For each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.
Table: UnitsSold

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| purchase_date | date    |
| units         | int     |
+---------------+---------+
There is no primary key for this table, it may contain duplicates.
Each row of this table indicates the date, units and product_id of each product sold. 
Write an SQL query to find the average selling price for each product.

average_price should be rounded to 2 decimal places.

The query result format is in the following example:

Prices table:

+------------+------------+------------+--------+
| product_id | start_date | end_date   | price  |
+------------+------------+------------+--------+
| 1          | 2019-02-17 | 2019-02-28 | 5      |
| 1          | 2019-03-01 | 2019-03-22 | 20     |
| 2          | 2019-02-01 | 2019-02-20 | 15     |
| 2          | 2019-02-21 | 2019-03-31 | 30     |
+------------+------------+------------+--------+
UnitsSold table:

+------------+---------------+-------+
| product_id | purchase_date | units |
+------------+---------------+-------+
| 1          | 2019-02-25    | 100   |
| 1          | 2019-03-01    | 15    |
| 2          | 2019-02-10    | 200   |
| 2          | 2019-03-22    | 30    |
+------------+---------------+-------+
Result table:

+------------+---------------+
| product_id | average_price |
+------------+---------------+
| 1          | 6.96          |
| 2          | 16.96         |
+------------+---------------+
Average selling price = Total Price of Product / Number of products sold.
Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96
Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96
-------------------------------------------------------------------------------------->

create table price (
product_id int,
start_date date,
end_date date,
price int);

create table unit_sold
(product_id int,
purchase_date date,
units int);

alter table price
add primary key (product_id, start_date, end_date);

insert into price values
(1,"2019-02-17","2019-02-28",5),(1,"2019-03-01","2019-03-22",20),
(2,"2019-02-01","2019-02-20",15),(2,"2019-02-21","2019-03-31",30);

select * from price;

insert into unit_sold values
(1,"2019-02-25",100),(1,"2019-03-01",15),(2,"2019-02-10",200),(2,"2019-03-22",30);

select * from unit_sold;

select round(sum(p.price*u.units)/sum(u.units),2) as avg, p.product_id
from price p
left join 
unit_sold u
on p.product_id=u.product_id
WHERE  u.purchase_date BETWEEN p.start_date AND p.end_date 
group by product_id;

============================================================================================================================================

Q41.
Warehouse Manager Problem

Description
LeetCode Problem 1571.

Table: Warehouse

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| name         | varchar |
| product_id   | int     |
| units        | int     |
+--------------+---------+
(name, product_id) is the primary key for this table.
Each row of this table contains the information of the products in each warehouse.
Table: Products

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| Width         | int     |
| Length        | int     |
| Height        | int     |
+---------------+---------+
product_id is the primary key for this table.
Each row of this table contains the information about the product dimensions (Width, Lenght and Height) in feets of each product.
Write an SQL query to report how much cubic feet of volume does the inventory occupy in each warehouse.

warehouse_name
volume Return the result table in any order.
The query result format is in the following example.

Warehouse table:
+------------+--------------+-------------+
| name       | product_id   | units       |
+------------+--------------+-------------+
| LCHouse1   | 1            | 1           |
| LCHouse1   | 2            | 10          |
| LCHouse1   | 3            | 5           |
| LCHouse2   | 1            | 2           |
| LCHouse2   | 2            | 2           |
| LCHouse3   | 4            | 1           |
+------------+--------------+-------------+

Products table:
+------------+--------------+------------+----------+-----------+
| product_id | product_name | Width      | Length   | Height    |
+------------+--------------+------------+----------+-----------+
| 1          | LC-TV        | 5          | 50       | 40        |
| 2          | LC-KeyChain  | 5          | 5        | 5         |
| 3          | LC-Phone     | 2          | 10       | 10        |
| 4          | LC-T-Shirt   | 4          | 10       | 20        |
+------------+--------------+------------+----------+-----------+

Result table:
+----------------+------------+
| warehouse_name | volume     | 
+----------------+------------+
| LCHouse1       | 12250      | 
| LCHouse2       | 20250      |
| LCHouse3       | 800        |
+----------------+------------+
Volume of product_id = 1 (LC-TV), 5x50x40 = 10000
Volume of product_id = 2 (LC-KeyChain), 5x5x5 = 125 
Volume of product_id = 3 (LC-Phone), 2x10x10 = 200
Volume of product_id = 4 (LC-T-Shirt), 4x10x20 = 800
LCHouse1: 1 unit of LC-TV + 10 units of LC-KeyChain + 5 units of LC-Phone.
          Total volume: 1*10000 + 10*125  + 5*200 = 12250 cubic feet
LCHouse2: 2 units of LC-TV + 2 units of LC-KeyChain.
          Total volume: 2*10000 + 2*125 = 20250 cubic feet
LCHouse3: 1 unit of LC-T-Shirt.
          Total volume: 1*800 = 800 cubic feet.
----------------------------------------------------------------------------------------->



create table wearhouse (
name varchar (20),
product_id int,
units int);

alter table wearhouse
add primary key (name, product_id);

create table product (
product_id int primary key,
product_name varchar(20),
Width int,
Length int,
Height int);

insert into wearhouse values
('LCHouse1',1,1),('LCHouse1',2,10),('LCHouse1',3,5),('LCHouse2',1,2),('LCHouse2',2,2),('LCHouse3',4,1);

select * from wearhouse;

insert into product values
(1,"LC-TV",5,50,40),(2,"LC-KeyChain",5,5,5),
(3,"LC-Phone",2,10,10),(4,"LC-T-Shirt",4,10,20);

select * from product;

select sum((Width*units)*(Length*Height)) as voulume,w.name
from wearhouse w
left join
product p
on w.product_id=p.product_id
group by name;
=================================================================================================================================================
Q42.
Table: Sales

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| sale_date     | date    |
| fruit         | enum    | 
| sold_num      | int     | 
+---------------+---------+
(sale_date,fruit) is the primary key for this table.
This table contains the sales of "apples" and "oranges" sold each day.
 

Write an SQL query to report the difference between number of apples and oranges sold each day.

Return the result table ordered by sale_date in format ('YYYY-MM-DD').

The query result format is in the following example:

 

Sales table:
+------------+------------+-------------+
| sale_date  | fruit      | sold_num    |
+------------+------------+-------------+
| 2020-05-01 | apples     | 10          |
| 2020-05-01 | oranges    | 8           |
| 2020-05-02 | apples     | 15          |
| 2020-05-02 | oranges    | 15          |
| 2020-05-03 | apples     | 20          |
| 2020-05-03 | oranges    | 0           |
| 2020-05-04 | apples     | 15          |
| 2020-05-04 | oranges    | 16          |
+------------+------------+-------------+

Result table:
+------------+--------------+
| sale_date  | diff         |
+------------+--------------+
| 2020-05-01 | 2            |
| 2020-05-02 | 0            |
| 2020-05-03 | 20           |
| 2020-05-04 | -1           |
+------------+--------------+

Day 2020-05-01, 10 apples and 8 oranges were sold (Difference  10 - 8 = 2).
Day 2020-05-02, 15 apples and 15 oranges were sold (Difference 15 - 15 = 0).
Day 2020-05-03, 20 apples and 0 oranges were sold (Difference 20 - 0 = 20).
Day 2020-05-04, 15 apples and 16 oranges were sold (Difference 15 - 16 = -1).
--------------------------------------------------------------------------------------->
create table sales(
sale_date date,
fruit varchar(20),
sold_num int);

insert into sales values
("2020-05-01","apples",10),("2020-05-01","oranges",8),("2020-05-02","apples",15),
("2020-05-02","oranges",15),("2020-05-03","apples",20),("2020-05-03","oranges",0),
("2020-05-04","apples",15),("2020-05-04","oranges",16);

select * from sales;

select s.sale_date,
sum(case
when fruit="apples" then s.sold_num
when fruit="oranges" then - s.sold_num
else 0
end)as diff
from sales as s
group by sale_date ;
=============================================================================================================================================
Q43.
Table: Activity

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some game.
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on some day using some device.
Write an SQL query that reports the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.

The query result format is in the following example:

Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
Result table:
+-----------+
| fraction  |
+-----------+
| 0.33      |
+-----------+
Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33
----------------------------------------------------------------------------------------------------------->

create table activity(
player_id int,
device_id int,
event_date date,
games_played int);

alter table activity 
add primary key (player_id, event_date);

insert into activity values
(1,2,"2016-03-01",5),(1,2,"2016-03-02",6),(2,3,"2017-06-25",1),(3,1,"2016-03-02",0),(3,4,"2018-07-03",5);

select * from activity;


WITH cte AS (
SELECT player_id, MIN(event_date) as first_login
FROM activity
GROUP BY player_id
)

SELECT ROUND(SUM(CASE WHEN DATEDIFF(event_date, first_login)=1 THEN 1 ELSE 0  END) / COUNT(DISTINCT cte.player_id), 2) as fraction
FROM activity as a
JOIN cte 
ON a.player_id = cte.player_id;

=================================================================================================================================================
Q44.
SQL Schema
Pandas Schema
Table: Employee

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| department  | varchar |
| managerId   | int     |
+-------------+---------+
id is the primary key (column with unique values) for this table.
Each row of this table indicates the name of an employee, their department, and the id of their manager.
If managerId is null, then the employee does not have a manager.
No employee will be the manager of themself.
 

Write a solution to find managers with at least five direct reports.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Employee table:
+-----+-------+------------+-----------+
| id  | name  | department | managerId |
+-----+-------+------------+-----------+
| 101 | John  | A          | None      |
| 102 | Dan   | A          | 101       |
| 103 | James | A          | 101       |
| 104 | Amy   | A          | 101       |
| 105 | Anne  | A          | 101       |
| 106 | Ron   | B          | 101       |
+-----+-------+------------+-----------+
Output: 
+------+
| name |
+------+
| John |
+------+
---------------------------------------------------------------->

create table employee(
id int primary key,
name varchar(30),
department varchar(30),
managerId int);

insert into employee values
(101,"John","A",Null),(102,"Dan","A",101),(103,"James","A",101),(104,'Amy','A',101),
(105,'Anne','A',101),(106,"Ron","B",101);

select * from employee;

select name from employee where id in
(select managerId from employee
group by managerId
having count(managerId)>=5) ;
===================================================================================================================================
Q45.

Problem

A university uses 2 data tables, student and department, to store data about its students and the departments associated with each major.

Write a query to print the respective department name and number of students majoring in each department for all departments in the department table (even ones with no current students).

Sort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name.

The student is described as follow:

Column Name	Type
student_id	Integer
student_name	String
gender	Character
dept_id	Integer
where student_id is the studentâ€™s ID number, student_name is the studentâ€™s name, gender is their gender, and dept_id is the department ID associated with their declared major.

And the department table is described as below:

Column Name	Type
dept_id	Integer
dept_name	String
where dept_id is the departmentâ€™s ID number and dept_name is the department name.

Here is an example input:
student table:

student_id	student_name	gender	dept_id
1	Jack	M	1
2	Jane	F	1
3	Mark	M	2
department table:

dept_id	dept_name
1	Engineering
2	Science
3	Law
The Output should be:

dept_name	student_number
Engineering	2
Science	1
Law	0
------------------------------------------------------------------------------------------------------------------>


create table student (
student_id int primary key,
student_name varchar (20),
gender varchar(30),
dept_id int);

insert into student values
(1,'Jack','M',1),(2,'Jane','F',1),(3,'Mark','M',2);

select * from student;

create table dept(
dept_id int primary key,
dept_name varchar(30));

insert into dept values
(1,"Engineering"),(2,'Science'),(3,'Law');

select * from dept; 

select dept_name ,
sum(case
when s.dept_id=d.dept_id then 1 
else 0
end )as student_count
from student s
right join 
dept d
on s.dept_id=d.dept_id
group by  dept_name;
===========================================================================================================================================

Q46.

table: Customer

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| customer_id | int     |
| product_key | int     |
+-------------+---------+
This table may contain duplicates rows. 
customer_id is not NULL.
product_key is a foreign key (reference column) to Product table.
 

Table: Product

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_key | int     |
+-------------+---------+
product_key is the primary key (column with unique values) for this table.
 

Write a solution to report the customer ids from the Customer table that bought all the products in the Product table.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Customer table:
+-------------+-------------+
| customer_id | product_key |
+-------------+-------------+
| 1           | 5           |
| 2           | 6           |
| 3           | 5           |
| 3           | 6           |
| 1           | 6           |
+-------------+-------------+
Product table:
+-------------+
| product_key |
+-------------+
| 5           |
| 6           |
+-------------+
Output: 
+-------------+
| customer_id |
+-------------+
| 1           |
| 3           |
+-------------+
Explanation: 
The customers who bought all the products (5 and 6) are customers with IDs 1 and 3.
------------------------------------------------------------------------------------------------>
create table customer (
customer_id int,
product_key int);

insert into customer values
(1,5),(2,6),(3,5),(3,6),(1,6);

select * from customer;
create table product(
product_key int primary key);

insert into product values
(5),(6);

select  customer_id from customer
group by customer_id
having  count(distinct product_key)=2;

===========================================================================================================================================================
Q47.
Table: Project

1
2
3
4
5
6
7
8
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| project_id  | int     |
| employee_id | int     |
+-------------+---------+
(project_id, employee_id) is the primary key of this table.
employee_id is a foreign key to Employee table.
Table: Employee

1
2
3
4
5
6
7
8
+------------------+---------+
| Column Name      | Type    |
+------------------+---------+
| employee_id      | int     |
| name             | varchar |
| experience_years | int     |
+------------------+---------+
employee_id is the primary key of this table.
Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years.

The query result format is in the following example:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+

Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 3                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+

Result table:
+-------------+---------------+
| project_id  | employee_id   |
+-------------+---------------+
| 1           | 1             |
| 1           | 3             |
| 2           | 1             |
+-------------+---------------+
Both employees with id 1 and 3 have the most experience among the employees 
------------------------------------------------------------------------------------------->
create table project (
project_id int,
employee_id int);
alter table project 
add primary key (project_id, employee_id);

create table emp(
employee_id int primary key,
name varchar (20),
experience_years int);

insert into project values
(1,1),(1,2),(1,3),(2,1),(2,4);

insert into emp values
(1,'Khaled',3),(2,"Ali",2),(3,"John",3),(4,"Doe",2);

select project_id,p.employee_id from project p
join 
emp e
on p.employee_id=e.employee_id
where experience_years=(select max(experience_years) from emp);
============================================================================================================================================
Q48.
Table: Books

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| book_id        | int     |
| name           | varchar |
| available_from | date    |
+----------------+---------+
book_id is the primary key of this table.
Table: Orders

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| order_id       | int     |
| book_id        | int     |
| quantity       | int     |
| dispatch_date  | date    |
+----------------+---------+
order_id is the primary key of this table.
book_id is a foreign key to the Books table.
Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23.

The query result format is in the following example:

Books table:
+---------+--------------------+----------------+
| book_id | name               | available_from |
+---------+--------------------+----------------+
| 1       | "Kalila And Demna" | 2010-01-01     |
| 2       | "28 Letters"       | 2012-05-12     |
| 3       | "The Hobbit"       | 2019-06-10     |
| 4       | "13 Reasons Why"   | 2019-06-01     |
| 5       | "The Hunger Games" | 2008-09-21     |
+---------+--------------------+----------------+

Orders table:
+----------+---------+----------+---------------+
| order_id | book_id | quantity | dispatch_date |
+----------+---------+----------+---------------+
| 1        | 1       | 2        | 2018-07-26    |
| 2        | 1       | 1        | 2018-11-05    |
| 3        | 3       | 8        | 2019-06-11    |
| 4        | 4       | 6        | 2019-06-05    |
| 5        | 4       | 5        | 2019-06-20    |
| 6        | 5       | 9        | 2009-02-02    |
| 7        | 5       | 8        | 2010-04-13    |
+----------+---------+----------+---------------+

Result table:
+-----------+--------------------+
| book_id   | name               |
+-----------+--------------------+
| 1         | "Kalila And Demna" |
| 2         | "28 Letters"       |
| 5         | "The Hunger Games" |
+-----------+--------------------+
----------------------------------------------------------------------->
create table book (
book_id int primary key,
name varchar (30),
available_from date);

insert into book values
(1,"Kalila AndDemna","2010-01-01"),(2,"28 Letters","2012-05-12"),(3,"The Hobbit","2019-06-10"),
(4,"13 Reasons Why","2019-06-01"),(5,"The Hunger Games","2008-09-21");

create table order1(
order_id int,
book_id int,
quantity int,
dispatch_date date);

insert into order1 values
(1,1,2,"2018-07-26"),(2,1,1,"2018-11-05"),( 3,3,8,"2019-06-11"),(4,4,6,"2019-06-05"),
(4,4,6,"2019-06-05"),(6,5,9,"2009-02-02"),(7,5,8,"2010-04-13");


select b.book_id,name from book b
left join 
order1 o
on b.book_id=o.book_id
where available_from <= date_sub("2019-06-23",interval 1 month) 
group by b.book_id
having sum(case
when dispatch_date between "2018-06-23"and "2019-06-23" then quantity
else 0 end)<10;
================================================================================================================================================
Q49.
-- Table: Enrollments

-- +---------------+---------+
-- | Column Name   | Type    |
-- +---------------+---------+
-- | student_id    | int     |
-- | course_id     | int     |
-- | grade         | int     |
-- +---------------+---------+
-- (student_id, course_id) is the primary key of this table.

-- Write a SQL query to find the highest grade with its corresponding course for each student. In case of a tie,
you should find the course with the smallest course_id. The output must be sorted by increasing student_id.

-- The query result format is in the following example:

-- Enrollments table:
-- +------------+-------------------+
-- | student_id | course_id | grade |
-- +------------+-----------+-------+
-- | 2          | 2         | 95    |
-- | 2          | 3         | 95    |
-- | 1          | 1         | 90    |
-- | 1          | 2         | 99    |
-- | 3          | 1         | 80    |
-- | 3          | 2         | 75    |
-- | 3          | 3         | 82    |
-- +------------+-----------+-------+

-- Result table:
-- +------------+-------------------+
-- | student_id | course_id | grade |
-- +------------+-----------+-------+
-- | 1          | 2         | 99    |
-- | 2          | 2         | 95    |
-- | 3          | 3         | 82    |
-- +------------+-----------+-------+
------------------------------------------------------------------------------>

create table enrollment(
student_id int,
course_id int,
grade int);

alter table enrollment 
add primary key (student_id, course_id);

insert into enrollment values
(2,2,95),(2,3,95),(1,1,90),(1,2,99),(3,1,80),(3,2,75),(3,3,82);

select * from enrollment;

select x.student_id,x.course_id ,x.grade from
(select *,
row_number()
over(partition by student_id order by grade desc) as rnk
from enrollment) x
where x.rnk=1;
============================================================================================================================================
Q50.

Table: Players

+-------------+-------+
| Column Name | Type  |
+-------------+-------+
| player_id   | int   |
| group_id    | int   |
+-------------+-------+
player_id is the primary key of this table.
Each row of this table indicates the group of each player.
Table: Matches

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| match_id      | int     |
| first_player  | int     |
| second_player | int     | 
| first_score   | int     |
| second_score  | int     |
+---------------+---------+

match_id is the primary key of this table.
Each row is a record of a match, first_player and second_player contain the player_id of each match.
first_score and second_score contain the number of points of the first_player and second_player respectively.
You may assume that, in each match, players belongs to the same group.
The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins.

Write an SQL query to find the winner in each group.

The query result format is in the following example:

Players table:
+-----------+------------+
| player_id | group_id   |
+-----------+------------+
| 15        | 1          |
| 25        | 1          |
| 30        | 1          |
| 45        | 1          |
| 10        | 2          |
| 35        | 2          |
| 50        | 2          |
| 20        | 3          |
| 40        | 3          |
+-----------+------------+

Matches table:
+------------+--------------+---------------+-------------+--------------+
| match_id   | first_player | second_player | first_score | second_score |
+------------+--------------+---------------+-------------+--------------+
| 1          | 15           | 45            | 3           | 0            |
| 2          | 30           | 25            | 1           | 2            |
| 3          | 30           | 15            | 2           | 0            |
| 4          | 40           | 20            | 5           | 2            |
| 5          | 35           | 50            | 1           | 1            |
+------------+--------------+---------------+-------------+--------------+

Result table:
+-----------+------------+
| group_id  | player_id  |
+-----------+------------+ 
| 1         | 15         |
| 2         | 35         |
| 3         | 40         |
+-----------+------------+
--------------------------------------------------------------------------------------------------------->

create table players(
player_id int primary key,
 group_id  int);
 
 insert into players values
 (15,1),(25,1),(30,1),(45,1),(10,2),(35,2),(50,2),(20,3),(40,3);
 
 create table matches(
 match_id int primary key,
first_player int,
second_player int,
first_score int,
second_score int);


insert into matches values
(1,15,45,3,0 ),(2,30,25,1,2),(3,30,15,2,0),
(4,40,20,5,2),(5,35,50,1,1);

select * from matches;


select group_id,player_id from
(select *,row_number()
over(partition by x.group_id)  as rnk from
(select group_id ,player_id ,sum(first_score) from players p
join 
matches m
on m.first_player=p.player_id
group by p.player_id 
union
select group_id ,player_id ,sum(second_score) from players p
join 
matches m
on m.second_player=p.player_id
group by p.player_id )x) y
where rnk=1;

=======================================================================END========================================================================================
=======================================================================END===================================================================================